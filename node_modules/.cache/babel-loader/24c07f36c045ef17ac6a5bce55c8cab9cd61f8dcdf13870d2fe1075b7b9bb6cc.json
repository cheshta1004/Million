{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst CastError = require('../error/cast');\nconst DocumentArrayElement = require('./documentArrayElement');\nconst EventEmitter = require('events').EventEmitter;\nconst SchemaArray = require('./array');\nconst SchemaDocumentArrayOptions = require('../options/schemaDocumentArrayOptions');\nconst SchemaType = require('../schemaType');\nconst discriminator = require('../helpers/model/discriminator');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst handleSpreadDoc = require('../helpers/document/handleSpreadDoc');\nconst utils = require('../utils');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\nconst InvalidSchemaOptionError = require('../error/invalidSchemaOption');\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\nconst documentArrayParent = require('../helpers/symbols').documentArrayParent;\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaArray\n * @api public\n */\n\nfunction SchemaDocumentArray(key, schema, options, schemaOptions) {\n  if (schema.options && schema.options.timeseries) {\n    throw new InvalidSchemaOptionError(key, 'timeseries');\n  }\n  const schemaTypeIdOption = SchemaDocumentArray.defaultOptions && SchemaDocumentArray.defaultOptions._id;\n  if (schemaTypeIdOption != null) {\n    schemaOptions = schemaOptions || {};\n    schemaOptions._id = schemaTypeIdOption;\n  }\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n  const EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n  SchemaArray.call(this, key, EmbeddedDocument, options);\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n  EmbeddedDocument.base = schema.base;\n  const fn = this.defaultValue;\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function () {\n      let arr = fn.call(this);\n      if (arr != null && !Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n  const $parentSchemaType = this;\n  this.$embeddedSchemaType = new DocumentArrayElement(key + '.$', {\n    required: this && this.schemaOptions && this.schemaOptions.required || false,\n    $parentSchemaType\n  });\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDocumentArray.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nSchemaDocumentArray.options = {\n  castNonArrays: true\n};\n\n/*!\n * Inherits from SchemaArray.\n */\nSchemaDocumentArray.prototype = Object.create(SchemaArray.prototype);\nSchemaDocumentArray.prototype.constructor = SchemaDocumentArray;\nSchemaDocumentArray.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/arraySubdocument'));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n    if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {\n      return;\n    }\n    this.$session(this.__parentArray.getArrayParent().$session());\n  }\n  schema._preCompile();\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n  EmbeddedDocument.base = schema.base;\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n  EmbeddedDocument.options = options;\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nSchemaDocumentArray.prototype.discriminator = function (name, schema, options) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n  options = options || {};\n  const tiedValue = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue, null, null, options?.overwriteExisting);\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidate = function (array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n  const _this = this;\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    return fn(err);\n  }\n  function cb(err) {\n    if (err) {\n      return fn(err);\n    }\n    let count = array && array.length;\n    let error;\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!utils.isMongooseDocumentArray(array)) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n      }\n      --count || fn(error);\n    }\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n        --count || fn(error);\n        continue;\n      }\n      doc.$__validate(null, options, callback);\n    }\n  }\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidateSync = function (array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    return schemaTypeError;\n  }\n  const count = array && array.length;\n  let resultError = null;\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n    if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n    const subdocValidateError = doc.validateSync(options);\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.getDefault = function (scope, init, options) {\n  let ret = typeof this.defaultValue === 'function' ? this.defaultValue.call(scope) : this.defaultValue;\n  if (ret == null) {\n    return ret;\n  }\n  if (options && options.skipCast) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n    const _subdoc = new Constructor({}, ret, undefined, undefined, i);\n    _subdoc.$init(ret[i]);\n    _subdoc.isNew = true;\n\n    // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n    ret[i] = _subdoc;\n  }\n  return ret;\n};\nconst _toObjectOptions = Object.freeze({\n  transform: false,\n  virtuals: false\n});\nconst initDocumentOptions = Object.freeze({\n  skipId: false,\n  willInit: true\n});\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nSchemaDocumentArray.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n\n  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n  let selected;\n  let subdoc;\n  options = options || {};\n  const path = options.path || this.path;\n  if (!Array.isArray(value)) {\n    if (!init && !SchemaDocumentArray.options.castNonArrays) {\n      throw new CastError('DocumentArray', value, this.path, null, this);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(path);\n    }\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  // We need to create a new array, otherwise change tracking will\n  // update the old doc (gh-4449)\n  if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {\n    value = new MongooseDocumentArray(value, path, doc);\n  }\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = path + '.' + options.arrayPathIndex;\n  }\n  const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;\n  const len = rawArray.length;\n  for (let i = 0; i < len; ++i) {\n    if (!rawArray[i]) {\n      continue;\n    }\n    const Constructor = getConstructor(this.casterConstructor, rawArray[i]);\n    const spreadDoc = handleSpreadDoc(rawArray[i], true);\n    if (rawArray[i] !== spreadDoc) {\n      rawArray[i] = spreadDoc;\n    }\n    if (rawArray[i] instanceof Subdocument) {\n      if (rawArray[i][documentArrayParent] !== doc) {\n        if (init) {\n          const subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n          rawArray[i] = subdoc.$init(rawArray[i]);\n        } else {\n          const subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);\n          rawArray[i] = subdoc;\n        }\n      }\n      // Might not have the correct index yet, so ensure it does.\n      if (rawArray[i].__index == null) {\n        rawArray[i].$setIndex(i);\n      }\n    } else if (rawArray[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        rawArray[i] = subdoc.$init(rawArray[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(rawArray[i]._id);\n        }\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(rawArray[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          rawArray[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            rawArray[i] = subdoc;\n          } catch (error) {\n            throw new CastError('embedded', rawArray[i], value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n  return value;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators);\n  return schematype;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.applyGetters = function (value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array the array to scope `fields` paths\n * @param {Object|undefined} fields the root fields selected in the query\n * @param {Boolean|undefined} init if we are being created part of a query result\n * @api private\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substring(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n  return hasKeys && selected || undefined;\n}\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.defaultOptions = {};\n\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n * @param {Any} value The value of the option you'd like to set.\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDocumentArray.set = SchemaType.set;\nSchemaDocumentArray.setters = [];\n\n/**\n * Attaches a getter for all DocumentArrayPath instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDocumentArray.get = SchemaType.get;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDocumentArray;","map":{"version":3,"names":["CastError","require","DocumentArrayElement","EventEmitter","SchemaArray","SchemaDocumentArrayOptions","SchemaType","discriminator","handleIdOption","handleSpreadDoc","utils","getConstructor","InvalidSchemaOptionError","arrayAtomicsSymbol","arrayPathSymbol","documentArrayParent","MongooseDocumentArray","Subdocument","SchemaDocumentArray","key","schema","options","schemaOptions","timeseries","schemaTypeIdOption","defaultOptions","_id","EmbeddedDocument","_createConstructor","prototype","$basePath","call","$isMongooseDocumentArray","Constructor","base","fn","defaultValue","default","arr","Array","isArray","$parentSchemaType","$embeddedSchemaType","required","caster","schemaName","castNonArrays","Object","create","constructor","OptionsConstructor","baseClass","apply","arguments","__parentArray","getArrayParent","$session","_preCompile","proto","$__setSchema","$isArraySubdocument","events","i","methods","statics","name","getFunctionName","tiedValue","isPOJO","value","clone","instanceOfSchema","casterConstructor","overwriteExisting","baseCasterConstructor","defineProperty","error","discriminators","doValidate","array","scope","_this","cb","err","count","length","updateValidator","isMongooseDocumentArray","path","callback","len","doc","undefined","validateModifiedOnly","$isModified","$__validate","doValidateSync","schemaTypeError","resultError","subdocValidateError","validateSync","getDefault","init","ret","skipCast","_subdoc","$init","isNew","assign","$__","activePaths","_toObjectOptions","freeze","transform","virtuals","initDocumentOptions","skipId","willInit","cast","prev","selected","subdoc","markModified","skipDocumentArrayCast","arrayPathIndex","rawArray","__array","spreadDoc","__index","$setIndex","scopePaths","id","deepEqual","toObject","set","schematype","validators","slice","requiredValidator","applyGetters","fields","keys","hasKeys","sub","startsWith","substring","setters","get","module","exports"],"sources":["C:/Users/chesh/OneDrive/Desktop/4 sem/FEE/Final project/node_modules/mongoose/lib/schema/documentArray.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('../error/cast');\nconst DocumentArrayElement = require('./documentArrayElement');\nconst EventEmitter = require('events').EventEmitter;\nconst SchemaArray = require('./array');\nconst SchemaDocumentArrayOptions =\n  require('../options/schemaDocumentArrayOptions');\nconst SchemaType = require('../schemaType');\nconst discriminator = require('../helpers/model/discriminator');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst handleSpreadDoc = require('../helpers/document/handleSpreadDoc');\nconst utils = require('../utils');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\nconst InvalidSchemaOptionError = require('../error/invalidSchemaOption');\n\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\nconst documentArrayParent = require('../helpers/symbols').documentArrayParent;\n\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaArray\n * @api public\n */\n\nfunction SchemaDocumentArray(key, schema, options, schemaOptions) {\n  if (schema.options && schema.options.timeseries) {\n    throw new InvalidSchemaOptionError(key, 'timeseries');\n  }\n  const schemaTypeIdOption = SchemaDocumentArray.defaultOptions &&\n    SchemaDocumentArray.defaultOptions._id;\n  if (schemaTypeIdOption != null) {\n    schemaOptions = schemaOptions || {};\n    schemaOptions._id = schemaTypeIdOption;\n  }\n\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n\n  const EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n\n  SchemaArray.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n\n  EmbeddedDocument.base = schema.base;\n\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function() {\n      let arr = fn.call(this);\n      if (arr != null && !Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n\n  const $parentSchemaType = this;\n  this.$embeddedSchemaType = new DocumentArrayElement(key + '.$', {\n    required: this &&\n      this.schemaOptions &&\n      this.schemaOptions.required || false,\n    $parentSchemaType\n  });\n\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDocumentArray.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nSchemaDocumentArray.options = { castNonArrays: true };\n\n/*!\n * Inherits from SchemaArray.\n */\nSchemaDocumentArray.prototype = Object.create(SchemaArray.prototype);\nSchemaDocumentArray.prototype.constructor = SchemaDocumentArray;\nSchemaDocumentArray.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/arraySubdocument'));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n    if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {\n      return;\n    }\n    this.$session(this.__parentArray.getArrayParent().$session());\n  }\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n  EmbeddedDocument.base = schema.base;\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nSchemaDocumentArray.prototype.discriminator = function(name, schema, options) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  options = options || {};\n  const tiedValue = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue, null, null, options?.overwriteExisting);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidate = function(array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n\n  const _this = this;\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!utils.isMongooseDocumentArray(array)) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n      }\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n\n      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n        --count || fn(error);\n        continue;\n      }\n\n      doc.$__validate(null, options, callback);\n    }\n  }\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidateSync = function(array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n\n    const subdocValidateError = doc.validateSync(options);\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.getDefault = function(scope, init, options) {\n  let ret = typeof this.defaultValue === 'function'\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  }\n\n  if (options && options.skipCast) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n    const _subdoc = new Constructor({}, ret, undefined,\n      undefined, i);\n    _subdoc.$init(ret[i]);\n    _subdoc.isNew = true;\n\n    // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n\n    ret[i] = _subdoc;\n  }\n\n  return ret;\n};\n\nconst _toObjectOptions = Object.freeze({ transform: false, virtuals: false });\nconst initDocumentOptions = Object.freeze({ skipId: false, willInit: true });\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nSchemaDocumentArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n\n  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n\n  let selected;\n  let subdoc;\n\n  options = options || {};\n\n  const path = options.path || this.path;\n\n  if (!Array.isArray(value)) {\n    if (!init && !SchemaDocumentArray.options.castNonArrays) {\n      throw new CastError('DocumentArray', value, this.path, null, this);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(path);\n    }\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  // We need to create a new array, otherwise change tracking will\n  // update the old doc (gh-4449)\n  if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {\n    value = new MongooseDocumentArray(value, path, doc);\n  }\n\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = path + '.' + options.arrayPathIndex;\n  }\n\n  const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;\n  const len = rawArray.length;\n\n  for (let i = 0; i < len; ++i) {\n    if (!rawArray[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.casterConstructor, rawArray[i]);\n\n    const spreadDoc = handleSpreadDoc(rawArray[i], true);\n    if (rawArray[i] !== spreadDoc) {\n      rawArray[i] = spreadDoc;\n    }\n\n    if (rawArray[i] instanceof Subdocument) {\n      if (rawArray[i][documentArrayParent] !== doc) {\n        if (init) {\n          const subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n          rawArray[i] = subdoc.$init(rawArray[i]);\n        } else {\n          const subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);\n          rawArray[i] = subdoc;\n        }\n      }\n      // Might not have the correct index yet, so ensure it does.\n      if (rawArray[i].__index == null) {\n        rawArray[i].$setIndex(i);\n      }\n    } else if (rawArray[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        rawArray[i] = subdoc.$init(rawArray[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(rawArray[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(rawArray[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          rawArray[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(rawArray[i], value, undefined,\n              undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            rawArray[i] = subdoc;\n          } catch (error) {\n            throw new CastError('embedded', rawArray[i],\n              value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({},\n    this.Constructor.discriminators);\n  return schematype;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.applyGetters = function(value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array the array to scope `fields` paths\n * @param {Object|undefined} fields the root fields selected in the query\n * @param {Boolean|undefined} init if we are being created part of a query result\n * @api private\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substring(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.defaultOptions = {};\n\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n * @param {Any} value The value of the option you'd like to set.\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDocumentArray.set = SchemaType.set;\n\nSchemaDocumentArray.setters = [];\n\n/**\n * Attaches a getter for all DocumentArrayPath instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDocumentArray.get = SchemaType.get;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDocumentArray;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}